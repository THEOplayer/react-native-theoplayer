
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <vector>

namespace facebook::react {

struct THEOplayerRCTViewConfigAdsImaStruct {
  std::string ppid{};
  double maxRedirects{0.0};
  bool autoPlayAdBreaks{false};
  std::string sessionID{};
  bool enableDebugMode{false};
  double bitrate{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, THEOplayerRCTViewConfigAdsImaStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_ppid = map.find("ppid");
  if (tmp_ppid != map.end()) {
    fromRawValue(context, tmp_ppid->second, result.ppid);
  }
  auto tmp_maxRedirects = map.find("maxRedirects");
  if (tmp_maxRedirects != map.end()) {
    fromRawValue(context, tmp_maxRedirects->second, result.maxRedirects);
  }
  auto tmp_autoPlayAdBreaks = map.find("autoPlayAdBreaks");
  if (tmp_autoPlayAdBreaks != map.end()) {
    fromRawValue(context, tmp_autoPlayAdBreaks->second, result.autoPlayAdBreaks);
  }
  auto tmp_sessionID = map.find("sessionID");
  if (tmp_sessionID != map.end()) {
    fromRawValue(context, tmp_sessionID->second, result.sessionID);
  }
  auto tmp_enableDebugMode = map.find("enableDebugMode");
  if (tmp_enableDebugMode != map.end()) {
    fromRawValue(context, tmp_enableDebugMode->second, result.enableDebugMode);
  }
  auto tmp_bitrate = map.find("bitrate");
  if (tmp_bitrate != map.end()) {
    fromRawValue(context, tmp_bitrate->second, result.bitrate);
  }
}

static inline std::string toString(const THEOplayerRCTViewConfigAdsImaStruct &value) {
  return "[Object THEOplayerRCTViewConfigAdsImaStruct]";
}

struct THEOplayerRCTViewConfigAdsStruct {
  std::vector<std::string> allowedMimeTypes{};
  bool uiEnabled{false};
  std::string preload{};
  std::string vpaidMode{};
  THEOplayerRCTViewConfigAdsImaStruct ima{};
  bool theoads{false};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, THEOplayerRCTViewConfigAdsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_allowedMimeTypes = map.find("allowedMimeTypes");
  if (tmp_allowedMimeTypes != map.end()) {
    fromRawValue(context, tmp_allowedMimeTypes->second, result.allowedMimeTypes);
  }
  auto tmp_uiEnabled = map.find("uiEnabled");
  if (tmp_uiEnabled != map.end()) {
    fromRawValue(context, tmp_uiEnabled->second, result.uiEnabled);
  }
  auto tmp_preload = map.find("preload");
  if (tmp_preload != map.end()) {
    fromRawValue(context, tmp_preload->second, result.preload);
  }
  auto tmp_vpaidMode = map.find("vpaidMode");
  if (tmp_vpaidMode != map.end()) {
    fromRawValue(context, tmp_vpaidMode->second, result.vpaidMode);
  }
  auto tmp_ima = map.find("ima");
  if (tmp_ima != map.end()) {
    fromRawValue(context, tmp_ima->second, result.ima);
  }
  auto tmp_theoads = map.find("theoads");
  if (tmp_theoads != map.end()) {
    fromRawValue(context, tmp_theoads->second, result.theoads);
  }
}

static inline std::string toString(const THEOplayerRCTViewConfigAdsStruct &value) {
  return "[Object THEOplayerRCTViewConfigAdsStruct]";
}

struct THEOplayerRCTViewConfigCastChromecastStruct {
  std::string appID{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, THEOplayerRCTViewConfigCastChromecastStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_appID = map.find("appID");
  if (tmp_appID != map.end()) {
    fromRawValue(context, tmp_appID->second, result.appID);
  }
}

static inline std::string toString(const THEOplayerRCTViewConfigCastChromecastStruct &value) {
  return "[Object THEOplayerRCTViewConfigCastChromecastStruct]";
}

struct THEOplayerRCTViewConfigCastStruct {
  THEOplayerRCTViewConfigCastChromecastStruct chromecast{};
  std::string strategy{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, THEOplayerRCTViewConfigCastStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_chromecast = map.find("chromecast");
  if (tmp_chromecast != map.end()) {
    fromRawValue(context, tmp_chromecast->second, result.chromecast);
  }
  auto tmp_strategy = map.find("strategy");
  if (tmp_strategy != map.end()) {
    fromRawValue(context, tmp_strategy->second, result.strategy);
  }
}

static inline std::string toString(const THEOplayerRCTViewConfigCastStruct &value) {
  return "[Object THEOplayerRCTViewConfigCastStruct]";
}

struct THEOplayerRCTViewConfigUiStruct {
  std::string language{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, THEOplayerRCTViewConfigUiStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_language = map.find("language");
  if (tmp_language != map.end()) {
    fromRawValue(context, tmp_language->second, result.language);
  }
}

static inline std::string toString(const THEOplayerRCTViewConfigUiStruct &value) {
  return "[Object THEOplayerRCTViewConfigUiStruct]";
}

struct THEOplayerRCTViewConfigMediaControlStruct {
  bool mediaSessionEnabled{false};
  double skipForwardInterval{0.0};
  double skipBackwardInterval{0.0};
  bool convertSkipToSeek{false};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, THEOplayerRCTViewConfigMediaControlStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_mediaSessionEnabled = map.find("mediaSessionEnabled");
  if (tmp_mediaSessionEnabled != map.end()) {
    fromRawValue(context, tmp_mediaSessionEnabled->second, result.mediaSessionEnabled);
  }
  auto tmp_skipForwardInterval = map.find("skipForwardInterval");
  if (tmp_skipForwardInterval != map.end()) {
    fromRawValue(context, tmp_skipForwardInterval->second, result.skipForwardInterval);
  }
  auto tmp_skipBackwardInterval = map.find("skipBackwardInterval");
  if (tmp_skipBackwardInterval != map.end()) {
    fromRawValue(context, tmp_skipBackwardInterval->second, result.skipBackwardInterval);
  }
  auto tmp_convertSkipToSeek = map.find("convertSkipToSeek");
  if (tmp_convertSkipToSeek != map.end()) {
    fromRawValue(context, tmp_convertSkipToSeek->second, result.convertSkipToSeek);
  }
}

static inline std::string toString(const THEOplayerRCTViewConfigMediaControlStruct &value) {
  return "[Object THEOplayerRCTViewConfigMediaControlStruct]";
}

struct THEOplayerRCTViewConfigStruct {
  std::string libraryLocation{};
  std::string mutedAutoplay{};
  THEOplayerRCTViewConfigAdsStruct ads{};
  THEOplayerRCTViewConfigCastStruct cast{};
  THEOplayerRCTViewConfigUiStruct ui{};
  THEOplayerRCTViewConfigMediaControlStruct mediaControl{};
  std::string license{};
  std::string licenseUrl{};
  bool chromeless{false};
  bool hlsDateRange{false};
  double liveOffset{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, THEOplayerRCTViewConfigStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_libraryLocation = map.find("libraryLocation");
  if (tmp_libraryLocation != map.end()) {
    fromRawValue(context, tmp_libraryLocation->second, result.libraryLocation);
  }
  auto tmp_mutedAutoplay = map.find("mutedAutoplay");
  if (tmp_mutedAutoplay != map.end()) {
    fromRawValue(context, tmp_mutedAutoplay->second, result.mutedAutoplay);
  }
  auto tmp_ads = map.find("ads");
  if (tmp_ads != map.end()) {
    fromRawValue(context, tmp_ads->second, result.ads);
  }
  auto tmp_cast = map.find("cast");
  if (tmp_cast != map.end()) {
    fromRawValue(context, tmp_cast->second, result.cast);
  }
  auto tmp_ui = map.find("ui");
  if (tmp_ui != map.end()) {
    fromRawValue(context, tmp_ui->second, result.ui);
  }
  auto tmp_mediaControl = map.find("mediaControl");
  if (tmp_mediaControl != map.end()) {
    fromRawValue(context, tmp_mediaControl->second, result.mediaControl);
  }
  auto tmp_license = map.find("license");
  if (tmp_license != map.end()) {
    fromRawValue(context, tmp_license->second, result.license);
  }
  auto tmp_licenseUrl = map.find("licenseUrl");
  if (tmp_licenseUrl != map.end()) {
    fromRawValue(context, tmp_licenseUrl->second, result.licenseUrl);
  }
  auto tmp_chromeless = map.find("chromeless");
  if (tmp_chromeless != map.end()) {
    fromRawValue(context, tmp_chromeless->second, result.chromeless);
  }
  auto tmp_hlsDateRange = map.find("hlsDateRange");
  if (tmp_hlsDateRange != map.end()) {
    fromRawValue(context, tmp_hlsDateRange->second, result.hlsDateRange);
  }
  auto tmp_liveOffset = map.find("liveOffset");
  if (tmp_liveOffset != map.end()) {
    fromRawValue(context, tmp_liveOffset->second, result.liveOffset);
  }
}

static inline std::string toString(const THEOplayerRCTViewConfigStruct &value) {
  return "[Object THEOplayerRCTViewConfigStruct]";
}
class THEOplayerRCTViewProps final : public ViewProps {
 public:
  THEOplayerRCTViewProps() = default;
  THEOplayerRCTViewProps(const PropsParserContext& context, const THEOplayerRCTViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  THEOplayerRCTViewConfigStruct config{};
};

} // namespace facebook::react
