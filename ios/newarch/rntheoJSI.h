/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  class JSI_EXPORT NativeAdsModuleCxxSpecJSI : public TurboModule {
protected:
  NativeAdsModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value playing(jsi::Runtime &rt, double tag) = 0;
  virtual void skip(jsi::Runtime &rt, double tag) = 0;
  virtual jsi::Value currentAdBreak(jsi::Runtime &rt, double tag) = 0;
  virtual jsi::Value currentAds(jsi::Runtime &rt, double tag) = 0;
  virtual jsi::Value scheduledAdBreaks(jsi::Runtime &rt, double tag) = 0;
  virtual void schedule(jsi::Runtime &rt, double tag, jsi::Object ad) = 0;
  virtual jsi::Value daiContentTimeForStreamTime(jsi::Runtime &rt, double tag, double time) = 0;
  virtual jsi::Value daiStreamTimeForContentTime(jsi::Runtime &rt, double tag, double time) = 0;
  virtual jsi::Value daiSnapback(jsi::Runtime &rt, double tag) = 0;
  virtual void daiSetSnapback(jsi::Runtime &rt, double tag, bool enabled) = 0;
  virtual void addFriendlyObstruction(jsi::Runtime &rt, double tag, jsi::Object obstruction) = 0;
  virtual void removeAllFriendlyObstructions(jsi::Runtime &rt, double tag) = 0;

};

template <typename T>
class JSI_EXPORT NativeAdsModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "THEORCTAdsModule";

protected:
  NativeAdsModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeAdsModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeAdsModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeAdsModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value playing(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::playing) == 2,
          "Expected playing(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::playing, jsInvoker_, instance_, std::move(tag));
    }
    void skip(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::skip) == 2,
          "Expected skip(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::skip, jsInvoker_, instance_, std::move(tag));
    }
    jsi::Value currentAdBreak(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::currentAdBreak) == 2,
          "Expected currentAdBreak(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::currentAdBreak, jsInvoker_, instance_, std::move(tag));
    }
    jsi::Value currentAds(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::currentAds) == 2,
          "Expected currentAds(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::currentAds, jsInvoker_, instance_, std::move(tag));
    }
    jsi::Value scheduledAdBreaks(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::scheduledAdBreaks) == 2,
          "Expected scheduledAdBreaks(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::scheduledAdBreaks, jsInvoker_, instance_, std::move(tag));
    }
    void schedule(jsi::Runtime &rt, double tag, jsi::Object ad) override {
      static_assert(
          bridging::getParameterCount(&T::schedule) == 3,
          "Expected schedule(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::schedule, jsInvoker_, instance_, std::move(tag), std::move(ad));
    }
    jsi::Value daiContentTimeForStreamTime(jsi::Runtime &rt, double tag, double time) override {
      static_assert(
          bridging::getParameterCount(&T::daiContentTimeForStreamTime) == 3,
          "Expected daiContentTimeForStreamTime(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::daiContentTimeForStreamTime, jsInvoker_, instance_, std::move(tag), std::move(time));
    }
    jsi::Value daiStreamTimeForContentTime(jsi::Runtime &rt, double tag, double time) override {
      static_assert(
          bridging::getParameterCount(&T::daiStreamTimeForContentTime) == 3,
          "Expected daiStreamTimeForContentTime(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::daiStreamTimeForContentTime, jsInvoker_, instance_, std::move(tag), std::move(time));
    }
    jsi::Value daiSnapback(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::daiSnapback) == 2,
          "Expected daiSnapback(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::daiSnapback, jsInvoker_, instance_, std::move(tag));
    }
    void daiSetSnapback(jsi::Runtime &rt, double tag, bool enabled) override {
      static_assert(
          bridging::getParameterCount(&T::daiSetSnapback) == 3,
          "Expected daiSetSnapback(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::daiSetSnapback, jsInvoker_, instance_, std::move(tag), std::move(enabled));
    }
    void addFriendlyObstruction(jsi::Runtime &rt, double tag, jsi::Object obstruction) override {
      static_assert(
          bridging::getParameterCount(&T::addFriendlyObstruction) == 3,
          "Expected addFriendlyObstruction(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addFriendlyObstruction, jsInvoker_, instance_, std::move(tag), std::move(obstruction));
    }
    void removeAllFriendlyObstructions(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::removeAllFriendlyObstructions) == 2,
          "Expected removeAllFriendlyObstructions(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeAllFriendlyObstructions, jsInvoker_, instance_, std::move(tag));
    }

  private:
    friend class NativeAdsModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeCacheModuleCxxSpecJSI : public TurboModule {
protected:
  NativeCacheModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void createTask(jsi::Runtime &rt, jsi::Object source, jsi::Object parameters) = 0;
  virtual jsi::Value getInitialState(jsi::Runtime &rt) = 0;
  virtual void renewLicense(jsi::Runtime &rt, jsi::String taskId, jsi::Object drmConfig) = 0;
  virtual void pauseCachingTask(jsi::Runtime &rt, jsi::String taskId) = 0;
  virtual void removeCachingTask(jsi::Runtime &rt, jsi::String taskId) = 0;
  virtual void startCachingTask(jsi::Runtime &rt, jsi::String taskId) = 0;

};

template <typename T>
class JSI_EXPORT NativeCacheModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "THEORCTCacheModule";

protected:
  NativeCacheModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeCacheModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeCacheModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeCacheModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    void createTask(jsi::Runtime &rt, jsi::Object source, jsi::Object parameters) override {
      static_assert(
          bridging::getParameterCount(&T::createTask) == 3,
          "Expected createTask(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::createTask, jsInvoker_, instance_, std::move(source), std::move(parameters));
    }
    jsi::Value getInitialState(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getInitialState) == 1,
          "Expected getInitialState(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getInitialState, jsInvoker_, instance_);
    }
    void renewLicense(jsi::Runtime &rt, jsi::String taskId, jsi::Object drmConfig) override {
      static_assert(
          bridging::getParameterCount(&T::renewLicense) == 3,
          "Expected renewLicense(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::renewLicense, jsInvoker_, instance_, std::move(taskId), std::move(drmConfig));
    }
    void pauseCachingTask(jsi::Runtime &rt, jsi::String taskId) override {
      static_assert(
          bridging::getParameterCount(&T::pauseCachingTask) == 2,
          "Expected pauseCachingTask(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::pauseCachingTask, jsInvoker_, instance_, std::move(taskId));
    }
    void removeCachingTask(jsi::Runtime &rt, jsi::String taskId) override {
      static_assert(
          bridging::getParameterCount(&T::removeCachingTask) == 2,
          "Expected removeCachingTask(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeCachingTask, jsInvoker_, instance_, std::move(taskId));
    }
    void startCachingTask(jsi::Runtime &rt, jsi::String taskId) override {
      static_assert(
          bridging::getParameterCount(&T::startCachingTask) == 2,
          "Expected startCachingTask(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::startCachingTask, jsInvoker_, instance_, std::move(taskId));
    }

  private:
    friend class NativeCacheModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeCastModuleCxxSpecJSI : public TurboModule {
protected:
  NativeCastModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value casting(jsi::Runtime &rt, double tag) = 0;
  virtual jsi::Value chromecastCasting(jsi::Runtime &rt, double tag) = 0;
  virtual jsi::Value airplayCasting(jsi::Runtime &rt, double tag) = 0;
  virtual jsi::Value chromecastState(jsi::Runtime &rt, double tag) = 0;
  virtual jsi::Value airplayState(jsi::Runtime &rt, double tag) = 0;
  virtual void chromecastStart(jsi::Runtime &rt, double tag) = 0;
  virtual void chromecastStop(jsi::Runtime &rt, double tag) = 0;
  virtual void chromecastJoin(jsi::Runtime &rt, double tag) = 0;
  virtual void chromecastLeave(jsi::Runtime &rt, double tag) = 0;
  virtual void airplayStart(jsi::Runtime &rt, double tag) = 0;
  virtual void airplayStop(jsi::Runtime &rt, double tag) = 0;

};

template <typename T>
class JSI_EXPORT NativeCastModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "THEORCTCastModule";

protected:
  NativeCastModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeCastModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeCastModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeCastModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value casting(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::casting) == 2,
          "Expected casting(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::casting, jsInvoker_, instance_, std::move(tag));
    }
    jsi::Value chromecastCasting(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::chromecastCasting) == 2,
          "Expected chromecastCasting(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::chromecastCasting, jsInvoker_, instance_, std::move(tag));
    }
    jsi::Value airplayCasting(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::airplayCasting) == 2,
          "Expected airplayCasting(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::airplayCasting, jsInvoker_, instance_, std::move(tag));
    }
    jsi::Value chromecastState(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::chromecastState) == 2,
          "Expected chromecastState(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::chromecastState, jsInvoker_, instance_, std::move(tag));
    }
    jsi::Value airplayState(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::airplayState) == 2,
          "Expected airplayState(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::airplayState, jsInvoker_, instance_, std::move(tag));
    }
    void chromecastStart(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::chromecastStart) == 2,
          "Expected chromecastStart(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::chromecastStart, jsInvoker_, instance_, std::move(tag));
    }
    void chromecastStop(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::chromecastStop) == 2,
          "Expected chromecastStop(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::chromecastStop, jsInvoker_, instance_, std::move(tag));
    }
    void chromecastJoin(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::chromecastJoin) == 2,
          "Expected chromecastJoin(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::chromecastJoin, jsInvoker_, instance_, std::move(tag));
    }
    void chromecastLeave(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::chromecastLeave) == 2,
          "Expected chromecastLeave(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::chromecastLeave, jsInvoker_, instance_, std::move(tag));
    }
    void airplayStart(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::airplayStart) == 2,
          "Expected airplayStart(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::airplayStart, jsInvoker_, instance_, std::move(tag));
    }
    void airplayStop(jsi::Runtime &rt, double tag) override {
      static_assert(
          bridging::getParameterCount(&T::airplayStop) == 2,
          "Expected airplayStop(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::airplayStop, jsInvoker_, instance_, std::move(tag));
    }

  private:
    friend class NativeCastModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeContentProtectionModuleCxxSpecJSI : public TurboModule {
protected:
  NativeContentProtectionModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void registerContentProtectionIntegration(jsi::Runtime &rt, jsi::String integrationId, jsi::String keySystemId) = 0;
  virtual void onBuildProcessed(jsi::Runtime &rt, jsi::Object payload) = 0;
  virtual void onCertificateRequest(jsi::Runtime &rt, jsi::Object payload) = 0;
  virtual void onCertificateRequestProcessedAsCertificate(jsi::Runtime &rt, jsi::Object payload) = 0;
  virtual void onCertificateRequestProcessedAsRequest(jsi::Runtime &rt, jsi::Object payload) = 0;
  virtual void onCertificateResponseProcessed(jsi::Runtime &rt, jsi::Object payload) = 0;
  virtual void onLicenseRequestProcessedAsLicense(jsi::Runtime &rt, jsi::Object payload) = 0;
  virtual void onLicenseRequestProcessedAsRequest(jsi::Runtime &rt, jsi::Object payload) = 0;
  virtual void onLicenseResponseProcessed(jsi::Runtime &rt, jsi::Object payload) = 0;
  virtual void onExtractFairplayContentIdProcessed(jsi::Runtime &rt, jsi::Object payload) = 0;

};

template <typename T>
class JSI_EXPORT NativeContentProtectionModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "THEORCTContentProtectionModule";

protected:
  NativeContentProtectionModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeContentProtectionModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeContentProtectionModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeContentProtectionModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    void registerContentProtectionIntegration(jsi::Runtime &rt, jsi::String integrationId, jsi::String keySystemId) override {
      static_assert(
          bridging::getParameterCount(&T::registerContentProtectionIntegration) == 3,
          "Expected registerContentProtectionIntegration(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::registerContentProtectionIntegration, jsInvoker_, instance_, std::move(integrationId), std::move(keySystemId));
    }
    void onBuildProcessed(jsi::Runtime &rt, jsi::Object payload) override {
      static_assert(
          bridging::getParameterCount(&T::onBuildProcessed) == 2,
          "Expected onBuildProcessed(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onBuildProcessed, jsInvoker_, instance_, std::move(payload));
    }
    void onCertificateRequest(jsi::Runtime &rt, jsi::Object payload) override {
      static_assert(
          bridging::getParameterCount(&T::onCertificateRequest) == 2,
          "Expected onCertificateRequest(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onCertificateRequest, jsInvoker_, instance_, std::move(payload));
    }
    void onCertificateRequestProcessedAsCertificate(jsi::Runtime &rt, jsi::Object payload) override {
      static_assert(
          bridging::getParameterCount(&T::onCertificateRequestProcessedAsCertificate) == 2,
          "Expected onCertificateRequestProcessedAsCertificate(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onCertificateRequestProcessedAsCertificate, jsInvoker_, instance_, std::move(payload));
    }
    void onCertificateRequestProcessedAsRequest(jsi::Runtime &rt, jsi::Object payload) override {
      static_assert(
          bridging::getParameterCount(&T::onCertificateRequestProcessedAsRequest) == 2,
          "Expected onCertificateRequestProcessedAsRequest(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onCertificateRequestProcessedAsRequest, jsInvoker_, instance_, std::move(payload));
    }
    void onCertificateResponseProcessed(jsi::Runtime &rt, jsi::Object payload) override {
      static_assert(
          bridging::getParameterCount(&T::onCertificateResponseProcessed) == 2,
          "Expected onCertificateResponseProcessed(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onCertificateResponseProcessed, jsInvoker_, instance_, std::move(payload));
    }
    void onLicenseRequestProcessedAsLicense(jsi::Runtime &rt, jsi::Object payload) override {
      static_assert(
          bridging::getParameterCount(&T::onLicenseRequestProcessedAsLicense) == 2,
          "Expected onLicenseRequestProcessedAsLicense(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onLicenseRequestProcessedAsLicense, jsInvoker_, instance_, std::move(payload));
    }
    void onLicenseRequestProcessedAsRequest(jsi::Runtime &rt, jsi::Object payload) override {
      static_assert(
          bridging::getParameterCount(&T::onLicenseRequestProcessedAsRequest) == 2,
          "Expected onLicenseRequestProcessedAsRequest(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onLicenseRequestProcessedAsRequest, jsInvoker_, instance_, std::move(payload));
    }
    void onLicenseResponseProcessed(jsi::Runtime &rt, jsi::Object payload) override {
      static_assert(
          bridging::getParameterCount(&T::onLicenseResponseProcessed) == 2,
          "Expected onLicenseResponseProcessed(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onLicenseResponseProcessed, jsInvoker_, instance_, std::move(payload));
    }
    void onExtractFairplayContentIdProcessed(jsi::Runtime &rt, jsi::Object payload) override {
      static_assert(
          bridging::getParameterCount(&T::onExtractFairplayContentIdProcessed) == 2,
          "Expected onExtractFairplayContentIdProcessed(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::onExtractFairplayContentIdProcessed, jsInvoker_, instance_, std::move(payload));
    }

  private:
    friend class NativeContentProtectionModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeEventBroadcastModuleCxxSpecJSI : public TurboModule {
protected:
  NativeEventBroadcastModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void broadcastEvent(jsi::Runtime &rt, double tag, jsi::Object event) = 0;

};

template <typename T>
class JSI_EXPORT NativeEventBroadcastModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "THEORCTEventBroadcastModule";

protected:
  NativeEventBroadcastModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeEventBroadcastModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeEventBroadcastModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeEventBroadcastModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    void broadcastEvent(jsi::Runtime &rt, double tag, jsi::Object event) override {
      static_assert(
          bridging::getParameterCount(&T::broadcastEvent) == 3,
          "Expected broadcastEvent(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::broadcastEvent, jsInvoker_, instance_, std::move(tag), std::move(event));
    }

  private:
    friend class NativeEventBroadcastModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativePlaybackSettingsModuleCxxSpecJSI : public TurboModule {
protected:
  NativePlaybackSettingsModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void useFastStartup(jsi::Runtime &rt, bool useFastStartup) = 0;
  virtual void setLipSyncCorrection(jsi::Runtime &rt, double correctionMs) = 0;

};

template <typename T>
class JSI_EXPORT NativePlaybackSettingsModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "THEORCTPlaybackSettingsModule";

protected:
  NativePlaybackSettingsModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePlaybackSettingsModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativePlaybackSettingsModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePlaybackSettingsModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    void useFastStartup(jsi::Runtime &rt, bool useFastStartup) override {
      static_assert(
          bridging::getParameterCount(&T::useFastStartup) == 2,
          "Expected useFastStartup(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::useFastStartup, jsInvoker_, instance_, std::move(useFastStartup));
    }
    void setLipSyncCorrection(jsi::Runtime &rt, double correctionMs) override {
      static_assert(
          bridging::getParameterCount(&T::setLipSyncCorrection) == 2,
          "Expected setLipSyncCorrection(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setLipSyncCorrection, jsInvoker_, instance_, std::move(correctionMs));
    }

  private:
    friend class NativePlaybackSettingsModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativePlayerModuleCxxSpecJSI : public TurboModule {
protected:
  NativePlayerModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value version(jsi::Runtime &rt) = 0;
  virtual void setPreload(jsi::Runtime &rt, double tag, jsi::String type) = 0;
  virtual void setCurrentTime(jsi::Runtime &rt, double tag, double seekTime) = 0;
  virtual void setPipConfig(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
  virtual void setBackgroundAudioConfig(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
  virtual void setPresentationMode(jsi::Runtime &rt, double tag, jsi::String mode) = 0;
  virtual void setMuted(jsi::Runtime &rt, double tag, bool muted) = 0;
  virtual void setPlaybackRate(jsi::Runtime &rt, double tag, double rate) = 0;
  virtual void setSelectedAudioTrack(jsi::Runtime &rt, double tag, std::optional<double> trackUid) = 0;
  virtual void setSelectedVideoTrack(jsi::Runtime &rt, double tag, std::optional<double> trackUid) = 0;
  virtual void setSelectedTextTrack(jsi::Runtime &rt, double tag, std::optional<double> trackUid) = 0;
  virtual void setSource(jsi::Runtime &rt, double tag, jsi::Object source) = 0;
  virtual void setTargetVideoQuality(jsi::Runtime &rt, double tag, jsi::Array qualities) = 0;
  virtual void setVolume(jsi::Runtime &rt, double tag, double volume) = 0;
  virtual void setAspectRatio(jsi::Runtime &rt, double tag, jsi::String ratio) = 0;
  virtual void setRenderingTarget(jsi::Runtime &rt, double tag, jsi::String target) = 0;
  virtual void setKeepScreenOn(jsi::Runtime &rt, double tag, bool keepScreenOn) = 0;
  virtual void setPaused(jsi::Runtime &rt, double tag, bool paused) = 0;
  virtual void setTextTrackStyle(jsi::Runtime &rt, double tag, jsi::Object style) = 0;
  virtual void setABRConfig(jsi::Runtime &rt, double tag, jsi::Object config) = 0;

};

template <typename T>
class JSI_EXPORT NativePlayerModuleCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "THEORCTPlayerModule";

protected:
  NativePlayerModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativePlayerModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativePlayerModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativePlayerModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value version(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::version) == 1,
          "Expected version(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::version, jsInvoker_, instance_);
    }
    void setPreload(jsi::Runtime &rt, double tag, jsi::String type) override {
      static_assert(
          bridging::getParameterCount(&T::setPreload) == 3,
          "Expected setPreload(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setPreload, jsInvoker_, instance_, std::move(tag), std::move(type));
    }
    void setCurrentTime(jsi::Runtime &rt, double tag, double seekTime) override {
      static_assert(
          bridging::getParameterCount(&T::setCurrentTime) == 3,
          "Expected setCurrentTime(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setCurrentTime, jsInvoker_, instance_, std::move(tag), std::move(seekTime));
    }
    void setPipConfig(jsi::Runtime &rt, double tag, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::setPipConfig) == 3,
          "Expected setPipConfig(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setPipConfig, jsInvoker_, instance_, std::move(tag), std::move(config));
    }
    void setBackgroundAudioConfig(jsi::Runtime &rt, double tag, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::setBackgroundAudioConfig) == 3,
          "Expected setBackgroundAudioConfig(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setBackgroundAudioConfig, jsInvoker_, instance_, std::move(tag), std::move(config));
    }
    void setPresentationMode(jsi::Runtime &rt, double tag, jsi::String mode) override {
      static_assert(
          bridging::getParameterCount(&T::setPresentationMode) == 3,
          "Expected setPresentationMode(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setPresentationMode, jsInvoker_, instance_, std::move(tag), std::move(mode));
    }
    void setMuted(jsi::Runtime &rt, double tag, bool muted) override {
      static_assert(
          bridging::getParameterCount(&T::setMuted) == 3,
          "Expected setMuted(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setMuted, jsInvoker_, instance_, std::move(tag), std::move(muted));
    }
    void setPlaybackRate(jsi::Runtime &rt, double tag, double rate) override {
      static_assert(
          bridging::getParameterCount(&T::setPlaybackRate) == 3,
          "Expected setPlaybackRate(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setPlaybackRate, jsInvoker_, instance_, std::move(tag), std::move(rate));
    }
    void setSelectedAudioTrack(jsi::Runtime &rt, double tag, std::optional<double> trackUid) override {
      static_assert(
          bridging::getParameterCount(&T::setSelectedAudioTrack) == 3,
          "Expected setSelectedAudioTrack(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setSelectedAudioTrack, jsInvoker_, instance_, std::move(tag), std::move(trackUid));
    }
    void setSelectedVideoTrack(jsi::Runtime &rt, double tag, std::optional<double> trackUid) override {
      static_assert(
          bridging::getParameterCount(&T::setSelectedVideoTrack) == 3,
          "Expected setSelectedVideoTrack(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setSelectedVideoTrack, jsInvoker_, instance_, std::move(tag), std::move(trackUid));
    }
    void setSelectedTextTrack(jsi::Runtime &rt, double tag, std::optional<double> trackUid) override {
      static_assert(
          bridging::getParameterCount(&T::setSelectedTextTrack) == 3,
          "Expected setSelectedTextTrack(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setSelectedTextTrack, jsInvoker_, instance_, std::move(tag), std::move(trackUid));
    }
    void setSource(jsi::Runtime &rt, double tag, jsi::Object source) override {
      static_assert(
          bridging::getParameterCount(&T::setSource) == 3,
          "Expected setSource(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setSource, jsInvoker_, instance_, std::move(tag), std::move(source));
    }
    void setTargetVideoQuality(jsi::Runtime &rt, double tag, jsi::Array qualities) override {
      static_assert(
          bridging::getParameterCount(&T::setTargetVideoQuality) == 3,
          "Expected setTargetVideoQuality(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setTargetVideoQuality, jsInvoker_, instance_, std::move(tag), std::move(qualities));
    }
    void setVolume(jsi::Runtime &rt, double tag, double volume) override {
      static_assert(
          bridging::getParameterCount(&T::setVolume) == 3,
          "Expected setVolume(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setVolume, jsInvoker_, instance_, std::move(tag), std::move(volume));
    }
    void setAspectRatio(jsi::Runtime &rt, double tag, jsi::String ratio) override {
      static_assert(
          bridging::getParameterCount(&T::setAspectRatio) == 3,
          "Expected setAspectRatio(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setAspectRatio, jsInvoker_, instance_, std::move(tag), std::move(ratio));
    }
    void setRenderingTarget(jsi::Runtime &rt, double tag, jsi::String target) override {
      static_assert(
          bridging::getParameterCount(&T::setRenderingTarget) == 3,
          "Expected setRenderingTarget(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setRenderingTarget, jsInvoker_, instance_, std::move(tag), std::move(target));
    }
    void setKeepScreenOn(jsi::Runtime &rt, double tag, bool keepScreenOn) override {
      static_assert(
          bridging::getParameterCount(&T::setKeepScreenOn) == 3,
          "Expected setKeepScreenOn(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setKeepScreenOn, jsInvoker_, instance_, std::move(tag), std::move(keepScreenOn));
    }
    void setPaused(jsi::Runtime &rt, double tag, bool paused) override {
      static_assert(
          bridging::getParameterCount(&T::setPaused) == 3,
          "Expected setPaused(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setPaused, jsInvoker_, instance_, std::move(tag), std::move(paused));
    }
    void setTextTrackStyle(jsi::Runtime &rt, double tag, jsi::Object style) override {
      static_assert(
          bridging::getParameterCount(&T::setTextTrackStyle) == 3,
          "Expected setTextTrackStyle(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setTextTrackStyle, jsInvoker_, instance_, std::move(tag), std::move(style));
    }
    void setABRConfig(jsi::Runtime &rt, double tag, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::setABRConfig) == 3,
          "Expected setABRConfig(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setABRConfig, jsInvoker_, instance_, std::move(tag), std::move(config));
    }

  private:
    friend class NativePlayerModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
